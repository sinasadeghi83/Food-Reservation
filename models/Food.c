#include "Food.h"
#include "../sinastd/Error.h"
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>
#include "../database/DbManager.h"
#include "../sinastd/Parser.h"

#define FOOD_MAX_FETCH 100
#define FOOD_TABLE "food"

static int foodsIndex = 0;
const char *FOOD_COLS[5] = {"id", "name", "type", "price", NULL};

// Food Creator
Food *FoodCreate(int id, char *name, FoodType type, int price)
{
    Food *food = malloc(sizeof(Food));
    FoodIntialise(food, id, name, type, price);
    return food;
}

// Food initiliser
void FoodIntialise(Food *this, int id, char *name, FoodType type, int price)
{
    this->id = id;
    // Copying string variables to this struct
    this->name = malloc(strlen(name) + 1);
    strcpy(this->name, name);
    this->type = type;
    this->price = price;
}

// Food destructor
void FoodFree(Food *this)
{
    if (this == NULL)
        return;
    if (this->name != NULL)
        free(this->name);
    free(this);
}

// FoodType from string
FoodType FoodTypeFromString(char *type)
{
    if (strcmp(type, "food") == 0)
        return FOOD_TYPE_FOOD;
    else if (strcmp(type, "dessert") == 0)
        return FOOD_TYPE_DESSERT;
    else
        return FOOD_TYPE_INVALID;
}

// FoodType to string
char *FoodTypeToString(FoodType type)
{
    switch (type)
    {
    case FOOD_TYPE_FOOD:
        return "food";
    case FOOD_TYPE_DESSERT:
        return "dessert";
    default:
        return ERR_INVALID;
    }
}

// Validate Food
Error *FoodValidate(Food *this)
{
    Error *err = ErrorCreate(false, NULL, NULL);
    // Check if food id is equal or less than 0
    if (this->id <= 0)
    {
        err->isAny = true;
        err->msg = "Food id is invalid";
        err->testMsg = ERR_INVALID;
    }
    if (this->name == NULL || strlen(this->name) == 0)
    {
        err->isAny = true;
        err->msg = "Food name is required";
        err->testMsg = ERR_INVALID;
    }
    if (this->price <= 0)
    {
        err->isAny = true;
        err->msg = "Food price is required";
        err->testMsg = ERR_INVALID;
    }
    if (this->type == FOOD_TYPE_INVALID)
    {
        err->isAny = true;
        err->msg = "Food type is required";
        err->testMsg = ERR_INVALID;
    }
    return err;
}

// Food Callback
int FoodCallback(void *data, int argc, char **argv, char **colName)
{
    if (foodsIndex == FOOD_MAX_FETCH - 1)
        return 0;
    Food **foods = (Food **)data;
    Food *food = FoodCreate(atoi(argv[0]), argv[1], FoodTypeFromString(argv[2]), atoi(argv[3]));
    foods[foodsIndex++] = food;
    foods[foodsIndex] = NULL;
    return 0;
}

// Find Foods from database by DbManager
Food **FoodFind(const char *whereCols[], const char *whereValues[])
{
    // Create a new array of Foods
    Food **foods = calloc(FOOD_MAX_FETCH, sizeof(Food *));
    foods[0] = NULL;
    bool status = DbSelect(FOOD_TABLE, whereCols, whereValues, FoodCallback, foods);
    foodsIndex = 0;
    if (!status || foods[0] == NULL)
    {
        free(foods);
        return NULL;
    }
    return foods;
}

// Free Foods array
void FoodFreeAll(Food **foods)
{
    if (foods == NULL)
        return;
    for (int i = 0; foods[i] != NULL; i++)
        FoodFree(foods[i]);
    free(foods);
}

// Free Foods array from some index
void FoodFreeAllFrom(Food **foods, int from)
{
    if (foods == NULL)
        return;
    for (int i = from; foods[i] != NULL; i++)
        FoodFree(foods[i]);
    free(foods);
}

// Save Food to database by DbManager
Error *FoodSave(Food *this)
{
    // If food is is equal to 0, it means that food is new and id will be generated by database
    if (this->id != 0)
    {
        // Check if food is already exist in database
        char *idStr = parseInt(this->id);
        Food **foods = FoodFind((const char *[]){"id", NULL},
                                (const char *[]){idStr, NULL});
        free(idStr);
        if (foods != NULL)
        {
            FoodFreeAll(foods);
            return ErrorCreate(true, "Food already exist", ERR_INVALID);
        }
        FoodFreeAll(foods);
    }
    // Validate food
    Error *err = FoodValidate(this);
    if (err->isAny)
        return err;
    char *idStr = parseInt(this->id);
    char *priceStr = parseInt(this->price);
    const char *values[5] = {
        idStr,
        this->name,
        FoodTypeToString(this->type),
        priceStr,
        NULL};
    int shift = this->id == 0;
    bool status = DbInsert(FOOD_TABLE, FOOD_COLS + shift, values + shift);
    free(idStr);
    free(priceStr);
    if (!status)
        return ErrorCreate(true, "Failed to save food", ERR_INVALID);
    return ErrorCreate(false, NULL, NULL);
}